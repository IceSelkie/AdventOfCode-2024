eval(fs.readFileSync("/Users/iceselkie/bin/utils2.js")+"");
i = await (() => new Promise((resolve, reject) => require('https').get({ hostname: 'adventofcode.com', path: '/2024/day/20/input', headers: { 'User-Agent': 'Human/1.0; NodeJS-Repl/v20.10.0; Darwin/15.2', 'Connection': 'keep-alive', 'Cookie': `session=${process.env.SESSION}`, 'Priority': 'u=0, i', 'Pragma': 'no-cache', 'Cache-Control': 'no-cache' } }, res => { let data = ''; res.on('data', chunk => data += chunk); res.on('end', () => resolve(data.trim())); }).on('error', reject)))();
i = await (() => new Promise((resolve, reject) => require('https').get({ hostname: 'adventofcode.com', path: '/2024/day/20/input', headers: { 'User-Agent': 'Human/1.0; NodeJS-Repl/v20.10.0; Darwin/15.2', 'Connection': 'keep-alive', 'Cookie': `session=${process.env.SESSION}`, 'Priority': 'u=0, i', 'Pragma': 'no-cache', 'Cache-Control': 'no-cache' } }, res => { let data = ''; res.on('data', chunk => data += chunk); res.on('end', () => resolve(data.trim())); }).on('error', reject)))();
ex = "###############\n#...#...#.....#\n#.#.#.#.#.###.#\n#S#...#.#.#...#\n#######.#.#.###\n#######.#.#...#\n#######.#.###.#\n###..E#...#...#\n###.#######.###\n#...###...#...#\n#.#####.#.###.#\n#.#...#.#.#...#\n#.#.#.#.#.#.###\n#...#...#...###\n###############"
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S"); g.map(a=>a.map(b=>b==="S"?".":b))
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S"); g.map(a=>a.map(b=>b==="S"?".":b)); queue=[[...pos,0,0]]; minv=0; minmap=new Set(); while (queue.length){let here=queue.findLast(a=>a[3]===minv); if (!here) {minv++; continue}; queue.splice(queue.lastIndexOf(here),1); let neighbors=dirs4.map(v=>vadd(v,here)); let toAdd=[]; if(here[2]>=1) neighbors.forEach(p=>toAdd.push([...p,here[2]-1,here[3]+1])); if (here[2]!==1) { neighbors.filter(p=>g[p[0]]?.[p[1]]&&g[p[0]][p[1]]!=="#").forEach(p=>toAdd.push([...p,here[2],here[3]+1])); }; toAdd.forEach(s=>{let key=s.slice(0,3).Js();if(!minmap.has(key)) queue.push(s);minmap.add(key)})}
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S"); g.map(a=>a.map(b=>b==="S"?".":b)); queue=[[...pos,0,0]]; minv=0; minmap=new Set(); found=[]; while (queue.length){let here=queue.findLast(a=>a[3]===minv); if (!here) {minv++; continue}; queue.splice(queue.lastIndexOf(here),1); let neighbors=dirs4.map(v=>vadd(v,here)); let toAdd=[]; if(here[2]>=1) neighbors.forEach(p=>toAdd.push([...p,here[2]-1,here[3]+1])); if (here[2]!==1) { neighbors.filter(p=>g[p[0]]?.[p[1]]&&g[p[0]][p[1]]!=="#").forEach(p=>toAdd.push([...p,here[2],here[3]+1])); }; toAdd.forEach(s=>{let key=s.slice(0,3).Js();if(!minmap.has(key)) queue.push(s);minmap.add(key); if(g[s[0]]?.[s[1]]==="E") found.push(s)})}
found
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S"); g.map(a=>a.map(b=>b==="S"?".":b)); queue=[[...pos,0,0]]; minv=0; minmap=new Set(); found=[]; while (queue.length){let here=queue.findLast(a=>a[3]===minv); if (!here) {minv++; continue}; queue.splice(queue.lastIndexOf(here),1); let neighbors=dirs4.map(v=>vadd(v,here)); let toAdd=[]; if(here[2]>=1) neighbors.forEach(p=>toAdd.push([...p,here[2]-1,here[3]+1])); if (here[2]!==1) { neighbors.filter(p=>g[p[0]]?.[p[1]]&&g[p[0]][p[1]]!=="#").forEach(p=>toAdd.push([...p,here[2],here[3]+1])); }; console.log({here,toAdd});toAdd.forEach(s=>{let key=s.slice(0,3).Js();if(!minmap.has(key)) queue.push(s);minmap.add(key); if(g[s[0]]?.[s[1]]==="E") found.push(s)})}
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S"); g.map(a=>a.map(b=>b==="S"?".":b)); queue=[[...pos,0,2]]; minv=0; minmap=new Set(); found=[]; while (queue.length){let here=queue.findLast(a=>a[3]===minv); if (!here) {minv++; continue}; queue.splice(queue.lastIndexOf(here),1); let neighbors=dirs4.map(v=>vadd(v,here)); let toAdd=[]; if(here[2]>=1) neighbors.forEach(p=>toAdd.push([...p,here[2]-1,here[3]+1])); if (here[2]!==1) { neighbors.filter(p=>g[p[0]]?.[p[1]]&&g[p[0]][p[1]]!=="#").forEach(p=>toAdd.push([...p,here[2],here[3]+1])); }; console.log({here,toAdd});toAdd.forEach(s=>{let key=s.slice(0,3).Js();if(!minmap.has(key)) queue.push(s);minmap.add(key); if(g[s[0]]?.[s[1]]==="E") found.push(s)})}
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S")[0].Jp(); g.map(a=>a.map(b=>b==="S"?".":b)); queue=[[...pos,0,2]]; minv=0; minmap=new Set(); found=[]; while (queue.length){let here=queue.findLast(a=>a[3]===minv); if (!here) {minv++; continue}; queue.splice(queue.lastIndexOf(here),1); let neighbors=dirs4.map(v=>vadd(v,here)); let toAdd=[]; if(here[2]>=1) neighbors.forEach(p=>toAdd.push([...p,here[2]-1,here[3]+1])); if (here[2]!==1) { neighbors.filter(p=>g[p[0]]?.[p[1]]&&g[p[0]][p[1]]!=="#").forEach(p=>toAdd.push([...p,here[2],here[3]+1])); }; console.log({here,toAdd});toAdd.forEach(s=>{let key=s.slice(0,3).Js();if(!minmap.has(key)) queue.push(s);minmap.add(key); if(g[s[0]]?.[s[1]]==="E") found.push(s)})}
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S")[0].Jp(); g.map(a=>a.map(b=>b==="S"?".":b)); queue=[[...pos,2,0]]; minv=0; minmap=new Set(); found=[]; while (queue.length){let here=queue.findLast(a=>a[3]===minv); if (!here) {minv++; continue}; queue.splice(queue.lastIndexOf(here),1); let neighbors=dirs4.map(v=>vadd(v,here)); let toAdd=[]; if(here[2]>=1) neighbors.forEach(p=>toAdd.push([...p,here[2]-1,here[3]+1])); if (here[2]!==1) { neighbors.filter(p=>g[p[0]]?.[p[1]]&&g[p[0]][p[1]]!=="#").forEach(p=>toAdd.push([...p,here[2],here[3]+1])); }; console.log({here,toAdd});toAdd.forEach(s=>{let key=s.slice(0,3).Js();if(!minmap.has(key)) queue.push(s);minmap.add(key); if(g[s[0]]?.[s[1]]==="E") found.push(s)})}
found.filter(a=>a[2]===2)
fullCost = found.filter(a=>a[2]===2).min(a=>a[3],true)
fullCost = found.filter(a=>a[2]===2).min(a=>a[3],true); found.filter(a=>a[2]>fullCost)
fullCost = found.filter(a=>a[2]===2).min(a=>a[3],true); found.filter(a=>a[3]<fullCost)
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S")[0].Jp(); g.map(a=>a.map(b=>b==="S"?".":b)); queue=[[...pos,2,null,0]]; minv=0; minmap=new Set(); found=[]; while (queue.length){let here=queue.findLast(a=>a[4]===minv); if (!here) {minv++; continue}; queue.splice(queue.lastIndexOf(here),1); let neighbors=dirs4.map(v=>vadd(v,here)); let toAdd=[]; if(here[2]>=1) neighbors.forEach(p=>toAdd.push([...p,here[2]-1,here[2]===2?here.slice(0,2).Js():here[3],here[4]+1])); if (here[2]!==1) { neighbors.filter(p=>g[p[0]]?.[p[1]]&&g[p[0]][p[1]]!=="#").forEach(p=>toAdd.push([...p,here[2],here[3],here[4]+1])); }; console.log({here,toAdd});toAdd.forEach(s=>{let key=s.slice(0,4).Js();if(!minmap.has(key)) queue.push(s);minmap.add(key); if(g[s[0]]?.[s[1]]==="E") found.push(s)})}
fullCost = found.filter(a=>a[2]===2).min(a=>a[3],true); found.filter(a=>a[3]<fullCost)
fullCost = found.filter(a=>a[2]===2).min(a=>a[4],true); found.filter(a=>a[4]<fullCost)
fullCost = found.filter(a=>a[2]===2).min(a=>a[4],true); console.log(fullCost); found.filter(a=>a[4]<fullCost)
fullCost = found.filter(a=>a[2]===2).min(a=>a[4],true); console.log(fullCost); found.filter(a=>a[4]<fullCost).map(a=>[a[3],a[4]]).groupBy(a=>a[1]).map(a=>[a[0],a[1].length])
fullCost = found.filter(a=>a[2]===2).min(a=>a[4],true); console.log(fullCost); found.filter(a=>a[4]<fullCost).map(a=>[a[3],a[4]]).groupBy(a=>a[1]).map(a=>[a[0],a[1].length]).sort()
fullCost = found.filter(a=>a[2]===2).min(a=>a[4],true); console.log(fullCost); found.filter(a=>a[4]<fullCost).map(a=>[a[3],a[4]]).groupBy(a=>a[1]).map(a=>[fullCost-a[0],a[1].length]).sort()
fullCost = found.filter(a=>a[2]===2).min(a=>a[4],true); console.log(fullCost); found.filter(a=>a[4]<fullCost).map(a=>[a[3],a[4]]).groupBy(a=>a[1]).map(a=>[fullCost-a[0],a[1].length]).sort((a,b)=>a[0]-b[0])
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S")[0].Jp(); g.map(a=>a.map(b=>b==="S"?".":b)); queue=[[...pos,2,null,null,0]]; minv=0; minmap=new Set(); found=[]; while (queue.length){let here=queue.findLast(a=>a[5]===minv); if (!here) {minv++; continue}; queue.splice(queue.lastIndexOf(here),1); let neighbors=dirs4.map(v=>vadd(v,here)); let toAdd=[]; if(here[2]>=1) neighbors.forEach(p=>toAdd.push([...p,here[2]-1,here[2]===2?here.slice(0,2).Js():here[3],here[2]===1?p.slice(0,2).Js():here[4],here[5]+1])); if (here[2]!==1) { neighbors.filter(p=>g[p[0]]?.[p[1]]&&g[p[0]][p[1]]!=="#").forEach(p=>toAdd.push([...p,here[2],here[3],here[4],here[5]+1])); }; console.log({here,toAdd});toAdd.forEach(s=>{let key=s.slice(0,5).Js();if(!minmap.has(key)) queue.push(s);minmap.add(key); if(g[s[0]]?.[s[1]]==="E") found.push(s)})}
fullCost = found.filter(a=>a[2]===2).min(a=>a[4],true); console.log(fullCost); found.filter(a=>a[4]<fullCost).map(a=>[a[3],a[4]]).groupBy(a=>a[1]).map(a=>[fullCost-a[0],a[1].length]).sort((a,b)=>a[0]-b[0])
fullCost = found.filter(a=>a[2]===2).min(a=>a[5],true); console.log(fullCost); found.filter(a=>a[5]<fullCost).map(a=>[a[3]+a[4],a[5]]).groupBy(a=>a[1]).map(a=>[fullCost-a[0],a[1].length]).sort((a,b)=>a[0]-b[0])
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S")[0].Jp(); g.map(a=>a.map(b=>b==="S"?".":b)); queue=[[...pos,2,null,null,0]]; minv=0; minmap=new Set(); found=[]; while (queue.length){let here=queue.findLast(a=>a[5]===minv); if (!here) {minv++; continue}; queue.splice(queue.lastIndexOf(here),1); let neighbors=dirs4.map(v=>vadd(v,here)); let toAdd=[]; if(here[2]>=1) neighbors.forEach(p=>toAdd.push([...p,here[2]-1,here[2]===2?here.slice(0,2).Js():here[3],here[2]===1?here.slice(0,2).Js():here[4],here[5]+1])); if (here[2]!==1) { neighbors.filter(p=>g[p[0]]?.[p[1]]&&g[p[0]][p[1]]!=="#").forEach(p=>toAdd.push([...p,here[2],here[3],here[4],here[5]+1])); }; /*console.log({here,toAdd});*/toAdd.forEach(s=>{let key=s.slice(0,5).Js();if(!minmap.has(key)) queue.push(s);minmap.add(key); if(g[s[0]]?.[s[1]]==="E") found.push(s)})}
fullCost = found.filter(a=>a[2]===2).min(a=>a[5],true); console.log(fullCost); found.filter(a=>a[5]<fullCost).map(a=>[a[3]+a[4],a[5]]).groupBy(a=>a[1]).map(a=>[fullCost-a[0],a[1].length]).sort((a,b)=>a[0]-b[0])
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S")[0].Jp(); g.map(a=>a.map(b=>b==="S"?".":b)); queue=[[...pos,2,null,null,0]]; minv=0; minmap=new Set(); found=[]; while (queue.length){let here=queue.findLast(a=>a[5]===minv); if (!here) {minv++; continue}; queue.splice(queue.lastIndexOf(here),1); let neighbors=dirs4.map(v=>vadd(v,here)); let toAdd=[]; if(here[2]>=1) neighbors.forEach(p=>toAdd.push([...p,here[2]-1,here[2]===2?p.slice(0,2).Js():here[3],here[2]===1?here.slice(0,2).Js():here[4],here[5]+1])); if (here[2]!==1) { neighbors.filter(p=>g[p[0]]?.[p[1]]&&g[p[0]][p[1]]!=="#").forEach(p=>toAdd.push([...p,here[2],here[3],here[4],here[5]+1])); }; /*console.log({here,toAdd});*/toAdd.forEach(s=>{let key=s.slice(0,5).Js();if(!minmap.has(key)) queue.push(s);minmap.add(key); if(g[s[0]]?.[s[1]]==="E") found.push(s)})}
fullCost = found.filter(a=>a[2]===2).min(a=>a[5],true); console.log(fullCost); found.filter(a=>a[5]<fullCost).map(a=>[a[3]+a[4],a[5]]).groupBy(a=>a[1]).map(a=>[fullCost-a[0],a[1].length]).sort((a,b)=>a[0]-b[0])
fullCost = found.filter(a=>a[2]===2).min(a=>a[5],true); console.log(fullCost); found.filter(a=>a[5]<fullCost).map(a=>[a[3]+a[4],a[5]]).groupBy(a=>a[1]).sort((a,b)=>a[0]-b[0])
fullCost = found.filter(a=>a[2]===2).min(a=>a[5],true); console.log(fullCost); found.filter(a=>a[5]<fullCost).map(a=>[a[3]+a[4],a[5]]).groupBy(a=>a[1]).sort((a,b)=>a[0]-b[0]).last
fullCost = found.filter(a=>a[2]===2).min(a=>a[5],true); console.log(fullCost); found.filter(a=>a[5]<fullCost).map(a=>[a[3]+a[4],a[5]]).groupBy(a=>a[1]).sort((a,b)=>b[0]-a[0]).last
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S")[0].Jp(); g.map(a=>a.map(b=>b==="S"?".":b)); queue=[[...pos,2,null,null,0]]; minv=0; minmap=new Set(); found=[]; while (queue.length){let here=queue.findLast(a=>a[5]===minv); if (!here) {minv++; continue}; queue.splice(queue.lastIndexOf(here),1); let neighbors=dirs4.map(v=>vadd(v,here)); let toAdd=[]; if(here[2]>=1) neighbors.forEach(p=>toAdd.push([...p,here[2]-1,here[2]===2?p.slice(0,2).Js():here[3],here[2]===1?p.slice(0,2).Js():here[4],here[5]+1])); if (here[2]!==1) { neighbors.filter(p=>g[p[0]]?.[p[1]]&&g[p[0]][p[1]]!=="#").forEach(p=>toAdd.push([...p,here[2],here[3],here[4],here[5]+1])); }; /*console.log({here,toAdd});*/toAdd.forEach(s=>{let key=s.slice(0,5).Js();if(!minmap.has(key)) queue.push(s);minmap.add(key); if(g[s[0]]?.[s[1]]==="E") found.push(s)})}
fullCost = found.filter(a=>a[2]===2).min(a=>a[5],true); console.log(fullCost); found.filter(a=>a[5]<fullCost).map(a=>[a[3]+a[4],a[5]]).groupBy(a=>a[1]).sort((a,b)=>b[0]-a[0]).last
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S")[0].Jp(); g.map(a=>a.map(b=>b==="S"?".":b)); queue=[[...pos,1,null,null,0]]; minv=0; minmap=new Set(); found=[]; while (queue.length){let here=queue.findLast(a=>a[5]===minv); if (!here) {minv++; continue}; queue.splice(queue.lastIndexOf(here),1); let neighbors=dirs4.map(v=>vadd(v,here)); let toAdd=[]; if(here[2]>=1) neighbors.forEach(p=>toAdd.push([...p,here[2]-1,here[2]===2?p.slice(0,2).Js():here[3],here[2]===1?p.slice(0,2).Js():here[4],here[5]+1])); if (here[2]!==1) { neighbors.filter(p=>g[p[0]]?.[p[1]]&&g[p[0]][p[1]]!=="#").forEach(p=>toAdd.push([...p,here[2],here[3],here[4],here[5]+1])); }; /*console.log({here,toAdd});*/toAdd.forEach(s=>{let key=s.slice(0,5).Js();if(!minmap.has(key)) queue.push(s);minmap.add(key); if(g[s[0]]?.[s[1]]==="E") found.push(s)})}
found
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S")[0].Jp(); g.map(a=>a.map(b=>b==="S"?".":b)); queue=[[...pos,2,null,null,0]]; minv=0; minmap=new Set(); found=[]; while (queue.length){let here=queue.findLast(a=>a[5]===minv); if (!here) {minv++; continue}; queue.splice(queue.lastIndexOf(here),1); let neighbors=dirs4.map(v=>vadd(v,here)); let toAdd=[]; if(here[2]==2) neighbors.forEach(p=>toAdd.push([...p,here[2]-1,here[2]===2?p.slice(0,2).Js():here[3],here[2]===1?p.slice(0,2).Js():here[4],here[5]+1])); if (here[2]!==1) { neighbors.filter(p=>g[p[0]]?.[p[1]]&&g[p[0]][p[1]]!=="#").forEach(p=>toAdd.push([...p,here[2],here[3],here[4],here[5]+1])); }; /*console.log({here,toAdd});*/toAdd.forEach(s=>{let key=s.slice(0,5).Js();if(!minmap.has(key)) queue.push(s);minmap.add(key); if(g[s[0]]?.[s[1]]==="E") found.push(s)})}
fullCost = found.filter(a=>a[2]===2).min(a=>a[5],true); console.log(fullCost); found.filter(a=>a[5]<fullCost).map(a=>[a[3]+a[4],a[5]]).groupBy(a=>a[1]).sort((a,b)=>b[0]-a[0]).last
found
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S")[0].Jp(); g.map(a=>a.map(b=>b==="S"?".":b)); queue=[[...pos,2,null,null,0]]; minv=0; minmap=new Set(); found=[]; while (queue.length){let here=queue.findLast(a=>a[5]===minv); if (!here) {minv++; continue}; queue.splice(queue.lastIndexOf(here),1); let neighbors=dirs4.map(v=>vadd(v,here)); let toAdd=[]; if(here[2]==2) neighbors.forEach(p=>toAdd.push([...p,here[2]-1,here[2]===2?p.slice(0,2).Js():here[3],here[2]===1?p.slice(0,2).Js():here[4],here[5]+1])); if (here[2]!==1) { neighbors.filter(p=>g[p[0]]?.[p[1]]&&g[p[0]][p[1]]!=="#").forEach(p=>toAdd.push([...p,here[2]?here[2]-1:here[2],here[3],here[2]===1?p.slice(0,2).Js():here[4],here[5]+1])); }; /*console.log({here,toAdd});*/toAdd.forEach(s=>{let key=s.slice(0,5).Js();if(!minmap.has(key)) queue.push(s);minmap.add(key); if(g[s[0]]?.[s[1]]==="E") found.push(s)})}
found
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S")[0].Jp(); g.map(a=>a.map(b=>b==="S"?".":b)); queue=[[...pos,2,null,null,0]]; minv=0; minmap=new Set(); found=[]; while (queue.length){let here=queue.findLast(a=>a[5]===minv); if (!here) {minv++; continue}; queue.splice(queue.lastIndexOf(here),1); let neighbors=dirs4.map(v=>vadd(v,here)); let toAdd=[]; if(here[2]==2) neighbors.forEach(p=>toAdd.push([...p,here[2]-1,here[2]===2?p.slice(0,2).Js():here[3],here[2]===1?p.slice(0,2).Js():here[4],here[5]+1])); if (here[2]!==1) { neighbors.filter(p=>g[p[0]]?.[p[1]]&&g[p[0]][p[1]]!=="#").forEach(p=>toAdd.push([...p,here[2]?here[2]-1:here[2],here[3],here[2]===1?p.slice(0,2).Js():here[4],here[5]+1])); }; console.log({here,toAdd});toAdd.forEach(s=>{let key=s.slice(0,5).Js();if(!minmap.has(key)) queue.push(s);minmap.add(key); if(g[s[0]]?.[s[1]]==="E") found.push(s)})}
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S")[0].Jp(); g.map(a=>a.map(b=>b==="S"?".":b)); queue=[[...pos,2,null,null,0]]; minv=0; minmap=new Set(); found=[]; while (queue.length){let here=queue.findLast(a=>a[5]===minv); if (!here) {minv++; continue}; queue.splice(queue.lastIndexOf(here),1); let neighbors=dirs4.map(v=>vadd(v,here)); let toAdd=[]; if(here[2]==2) neighbors.forEach(p=>toAdd.push([...p,here[2]-1,here[2]===2?p.slice(0,2).Js():here[3],here[2]===1?p.slice(0,2).Js():here[4],here[5]+1])); if (here[2]!==1) { neighbors.filter(p=>g[p[0]]?.[p[1]]&&g[p[0]][p[1]]!=="#").forEach(p=>toAdd.push([...p,here[2]===1?here[2]-1:here[2],here[3],here[2]===1?p.slice(0,2).Js():here[4],here[5]+1])); }; console.log({here,toAdd});toAdd.forEach(s=>{let key=s.slice(0,5).Js();if(!minmap.has(key)) queue.push(s);minmap.add(key); if(g[s[0]]?.[s[1]]==="E") found.push(s)})}
found
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S")[0].Jp(); g.map(a=>a.map(b=>b==="S"?".":b)); queue=[[...pos,2,null,null,0]]; minv=0; minmap=new Set(); found=[]; while (queue.length){let here=queue.findLast(a=>a[5]===minv); if (!here) {minv++; continue}; queue.splice(queue.lastIndexOf(here),1); let neighbors=dirs4.map(v=>vadd(v,here)); let toAdd=[]; if(here[2]==2) neighbors.forEach(p=>toAdd.push([...p,here[2]-1,here[2]===2?p.slice(0,2).Js():here[3],here[2]===1?p.slice(0,2).Js():here[4],here[5]+1])); if (here[2]!==1||true) { neighbors.filter(p=>g[p[0]]?.[p[1]]&&g[p[0]][p[1]]!=="#").forEach(p=>toAdd.push([...p,here[2]===1?here[2]-1:here[2],here[3],here[2]===1?p.slice(0,2).Js():here[4],here[5]+1])); }; console.log({here,toAdd});toAdd.forEach(s=>{let key=s.slice(0,5).Js();if(!minmap.has(key)) queue.push(s);minmap.add(key); if(g[s[0]]?.[s[1]]==="E") found.push(s)})}
fullCost = found.filter(a=>a[2]===2).min(a=>a[5],true); console.log(fullCost); found.filter(a=>a[5]<fullCost).map(a=>[a[3]+a[4],a[5]]).groupBy(a=>a[1]).sort((a,b)=>b[0]-a[0]).last
fullCost = found.filter(a=>a[2]===2).min(a=>a[5],true); console.log(fullCost); found.filter(a=>a[5]<fullCost).map(a=>[a[3]+a[4],a[5]]).groupBy(a=>a[1]).map(a=>[fullCost-a[0],a[1]]).sort((a,b)=>a[0]-b[0])
fullCost = found.filter(a=>a[2]===2).min(a=>a[5],true); console.log(fullCost); found.filter(a=>a[5]<fullCost).map(a=>[a[3]+a[4],a[5]]).groupBy(a=>a[1]).map(a=>[fullCost-a[0],a[1]]).sort((a,b)=>a[0]-b[0]).map(a=>[a[0],a[1].length])
fullCost = found.filter(a=>a[2]===2).min(a=>a[5],true); console.log(fullCost); found.filter(a=>a[5]<fullCost).map(a=>[a[3]+a[4],a[5]]).groupBy(a=>a[1]).map(a=>[fullCost-a[0],a[1]]).sort((a,b)=>a[0]-b[0])[10]
fullCost = found.filter(a=>a[2]===2).min(a=>a[5],true); console.log(fullCost); found.filter(a=>a[5]<fullCost).map(a=>[a[3]+a[4],a[5]]).groupBy(a=>a[1]).map(a=>[fullCost-a[0],a[1]]).sort((a,b)=>a[0]-b[0])[11]
found
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S")[0].Jp(); g.map(a=>a.map(b=>b==="S"?".":b)); queue=[[...pos,2,null,null,0]]; minv=0; minmap=new Set(); found=[]; while (queue.length){let here=queue.findLast(a=>a[5]===minv); if (!here) {minv++; continue}; queue.splice(queue.lastIndexOf(here),1); let neighbors=dirs4.map(v=>vadd(v,here)); let toAdd=[]; if(here[2]==2) neighbors.forEach(p=>toAdd.push([...p,here[2]-1,here[2]===2?p.slice(0,2).Js():here[3],here[2]===1?p.slice(0,2).Js():here[4],here[5]+1])); if (here[2]!==1||true) { neighbors.filter(p=>g[p[0]]?.[p[1]]&&g[p[0]][p[1]]!=="#").forEach(p=>toAdd.push([...p,here[2]===1?here[2]-1:here[2],here[3],here[2]===1?p.slice(0,2).Js():here[4],here[5]+1])); }; /*console.log({here,toAdd});*/ toAdd.forEach(s=>{let key=s.slice(0,5).Js();if(!minmap.has(key)) queue.push(s);minmap.add(key); if(g[s[0]]?.[s[1]]==="E") found.push(s)})}; found=found.map(a=>[a.slice(0,5),a[5]])
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S")[0].Jp(); g.map(a=>a.map(b=>b==="S"?".":b)); queue=[[...pos,2,null,null,0]]; minv=0; minmap=new Set(); found=[]; while (queue.length){let here=queue.findLast(a=>a[5]===minv); if (!here) {minv++; continue}; queue.splice(queue.lastIndexOf(here),1); let neighbors=dirs4.map(v=>vadd(v,here)); let toAdd=[]; if(here[2]==2) neighbors.forEach(p=>toAdd.push([...p,here[2]-1,here[2]===2?p.slice(0,2).Js():here[3],here[2]===1?p.slice(0,2).Js():here[4],here[5]+1])); if (here[2]!==1||true) { neighbors.filter(p=>g[p[0]]?.[p[1]]&&g[p[0]][p[1]]!=="#").forEach(p=>toAdd.push([...p,here[2]===1?here[2]-1:here[2],here[3],here[2]===1?p.slice(0,2).Js():here[4],here[5]+1])); }; /*console.log({here,toAdd});*/ toAdd.forEach(s=>{let key=s.slice(0,5).Js();if(!minmap.has(key)) queue.push(s);minmap.add(key); if(g[s[0]]?.[s[1]]==="E") found.push(s)})}; foundM=new Map();found.forEach(a=>{let k=a.slice(0,5).Js(); foundM.set(k,Math.min(foundM.get(k),a[5]))});
Math.min(undefined,3)
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S")[0].Jp(); g.map(a=>a.map(b=>b==="S"?".":b)); queue=[[...pos,2,null,null,0]]; minv=0; minmap=new Set(); found=[]; while (queue.length){let here=queue.findLast(a=>a[5]===minv); if (!here) {minv++; continue}; queue.splice(queue.lastIndexOf(here),1); let neighbors=dirs4.map(v=>vadd(v,here)); let toAdd=[]; if(here[2]==2) neighbors.forEach(p=>toAdd.push([...p,here[2]-1,here[2]===2?p.slice(0,2).Js():here[3],here[2]===1?p.slice(0,2).Js():here[4],here[5]+1])); if (here[2]!==1||true) { neighbors.filter(p=>g[p[0]]?.[p[1]]&&g[p[0]][p[1]]!=="#").forEach(p=>toAdd.push([...p,here[2]===1?here[2]-1:here[2],here[3],here[2]===1?p.slice(0,2).Js():here[4],here[5]+1])); }; /*console.log({here,toAdd});*/ toAdd.forEach(s=>{let key=s.slice(0,5).Js();if(!minmap.has(key)) queue.push(s);minmap.add(key); if(g[s[0]]?.[s[1]]==="E") found.push(s)})}; foundM=new Map();found.forEach(a=>{let k=a.slice(0,5).Js(); foundM.set(k,Math.min(foundM.get(k)||Infinity,a[5]))});
Math.min(Infinity,3)
temp=ex; g=temp.grid(); pos = temp.gridl().find(a=>a[1]==="S")[0].Jp(); g.map(a=>a.map(b=>b==="S"?".":b)); queue=[[...pos,2,null,null,0]]; minv=0; minmap=new Set(); found=[]; while (queue.length){let here=queue.findLast(a=>a[5]===minv); if (!here) {minv++; continue}; queue.splice(queue.lastIndexOf(here),1); let neighbors=dirs4.map(v=>vadd(v,here)); let toAdd=[]; if(here[2]==2) neighbors.forEach(p=>toAdd.push([...p,here[2]-1,here[2]===2?p.slice(0,2).Js():here[3],here[2]===1?p.slice(0,2).Js():here[4],here[5]+1])); if (here[2]!==1||true) { neighbors.filter(p=>g[p[0]]?.[p[1]]&&g[p[0]][p[1]]!=="#").forEach(p=>toAdd.push([...p,here[2]===1?here[2]-1:here[2],here[3],here[2]===1?p.slice(0,2).Js():here[4],here[5]+1])); }; /*console.log({here,toAdd});*/ toAdd.forEach(s=>{let key=s.slice(0,5).Js();if(!minmap.has(key)) queue.push(s);minmap.add(key); if(g[s[0]]?.[s[1]]==="E") found.push(s)})}; foundM=new Map();found.forEach(a=>{let k=a.slice(0,5).Js(); foundM.set(k,Math.min(foundM.get(k)||Infinity,a[5]))}); found = [...foundM.entries()].map(([k,v])=>[...k.Jp(),v])
fullCost = found.filter(a=>a[2]===2).min(a=>a[5],true); console.log(fullCost); found.filter(a=>a[5]<fullCost).map(a=>[a[3]+a[4],a[5]]).groupBy(a=>a[1]).map(a=>[fullCost-a[0],a[1]]).sort((a,b)=>a[0]-b[0])
fullCost = found.filter(a=>a[2]===2).min(a=>a[5],true); console.log(fullCost); found.filter(a=>a[5]<fullCost).map(a=>[a[3]+a[4],a[5]]).groupBy(a=>a[1]).map(a=>[fullCost-a[0],a[1]]).sort((a,b)=>a[0]-b[0]).map(a=>a[0]+"."+a[1].length)