eval(fs.readFileSync("/Users/iceselkie/bin/utils2.js")+"");
i = await (() => new Promise((resolve, reject) => require('https').get({ hostname: 'adventofcode.com', path: '/2024/day/16/input', headers: { 'User-Agent': 'Human/1.0; NodeJS-Repl/v20.10.0; Darwin/15.2', 'Connection': 'keep-alive', 'Cookie': `session=${process.env.SESSION}`, 'Priority': 'u=0, i', 'Pragma': 'no-cache', 'Cache-Control': 'no-cache' } }, res => { let data = ''; res.on('data', chunk => data += chunk); res.on('end', () => resolve(data.trim())); }).on('error', reject)))();
i.grid();
g=i.grid();pos=i.gridl().find(a=>a[1]==="S".length)
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0]
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();
ex="###############\n#.......#....E#\n#.#.###.#.###.#\n#.....#.#...#.#\n#.###.#####.#.#\n#.#.#.......#.#\n#.#.#####.###.#\n#...........#.#\n###.#.#####.#.#\n#...#.....#.#.#\n#.#.#.###.#.#.#\n#.....#...#.#.#\n#.###.#.#.#.#.#\n#S..#.....#...#\n###############"
dirs4
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]]; found=[];while (queue.length){let here=queue.min(a=>a[2]); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000]].filter(a=>get(a[0])!=="#"); next.forEach(n=>{queue.push(n);if(get(n[0])==="E")found.push(n);})}
get=([x,y])=>g[x][y]
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]]; found=[];while (queue.length){let here=queue.min(a=>a[2]); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000]].filter(a=>get(a[0])!=="#"); next.forEach(n=>{queue.push(n);if(get(n[0])==="E")found.push(n);})}
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]]; found=[];while (queue.length){let here=queue.min(a=>a[2]);queue.splice(queue.indexOf(here),1); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000]].filter(a=>get(a[0])!=="#"); next.forEach(n=>{queue.push(n);if(get(n[0])==="E")found.push(n);})}
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]]; found=[];while (queue.length){let here=queue.min(a=>a[2]);console.log('removed',queue.splice(queue.indexOf(here),1)); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000]].filter(a=>get(a[0])!=="#"); next.forEach(n=>{queue.push(n);if(get(n[0])==="E")found.push(n);})}
g=ex.grid();pos=ex.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]]; found=[];while (queue.length){let here=queue.min(a=>a[2]);console.log('removed',queue.splice(queue.indexOf(here),1)); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000]].filter(a=>get(a[0])!=="#"); next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}
found.min(a=>a[2])
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]]; found=[];while (queue.length){let here=queue.min(a=>a[2]);console.log('removed',queue.splice(queue.indexOf(here),1)); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000]].filter(a=>get(a[0])!=="#"); next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found.min(a=>a[2])
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]]; found=[];while (queue.length){let here=queue.min(a=>a[2]);queue.splice(queue.indexOf(here),1); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000]].filter(a=>get(a[0])!=="#"); next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found.min(a=>a[2])
g=ex.grid();pos=ex.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]]; found=[];while (queue.length){let here=queue.min(a=>a[2]);queue.splice(queue.indexOf(here),1); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000]].filter(a=>get(a[0])!=="#"); next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found.min(a=>a[2])
g=ex.grid();pos=ex.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]]; found=[];while (queue.length){let here=queue.min(a=>a[2]);queue.splice(queue.indexOf(here),1); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000]].filter(a=>get(a[0])!=="#"); next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found.min(a=>a[2],true)
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]]; found=[];while (queue.length){let here=queue.min(a=>a[2]);queue.splice(queue.indexOf(here),1); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000]].filter(a=>get(a[0])!=="#"); next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found.min(a=>a[2],true)
g=ex.grid();pos=ex.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=new Map([0,[[pos,0,0]]]); lowest=0; found=[];while (queue.size){let here=[];while(here?.length<1)here=queue.get(lowest);here=here.pop();if(true)console.log(here); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000]].filter(a=>get(a[0])!=="#"); next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found.min(a=>a[2],true)
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]]; lowest=0; found=[];while (queue.length){let here=queue.min(a=>a[2]);if(here[2]>lowest)console.log(lowest=here[2]);queue.splice(queue.indexOf(here),1); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000]].filter(a=>get(a[0])!=="#"); next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found.min(a=>a[2],true)
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]]; lowest=0; found=[];while (queue.length){let here=queue.min(a=>a[2]);if(here[2]>lowest)console.log({lowest:(lowest=here[2]),queueSize:queue.length});queue.splice(queue.indexOf(here),1); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000]].filter(a=>get(a[0])!=="#"); next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found.min(a=>a[2],true)
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]];dontReturn=new Set(); lowest=0; found=[];while (queue.length){let here=queue.min(a=>a[2]);if(here[2]>lowest)console.log({lowest:(lowest=here[2]),queueSize:queue.length});queue.splice(queue.indexOf(here),1); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000],[here[0],(here[1]+2)%4,here[2]+2000]].filter(a=>get(a[0])!=="#"&&!dontReturn.has(a[0].Js())); dontReturn.add(here[0].Js());next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found.min(a=>a[2],true)
g=ex.grid();pos=ex.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]];dontReturn=new Set(); lowest=0; found=[];while (queue.length){let here=queue.min(a=>a[2]);if(here[2]>lowest)console.log({lowest:(lowest=here[2]),queueSize:queue.length});queue.splice(queue.indexOf(here),1); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000],[here[0],(here[1]+2)%4,here[2]+2000]].filter(a=>get(a[0])!=="#"&&!dontReturn.has(a[0].Js())); dontReturn.add(here[0].Js());next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found.min(a=>a[2],true)
ex2="#################\n#...#...#...#..E#\n#.#.#.#.#.#.#.#.#\n#.#.#.#...#...#.#\n#.#.#.#.###.#.#.#\n#...#.#.#.....#.#\n#.#.#.#.#.#####.#\n#.#...#.#.#.....#\n#.#.#####.#.###.#\n#.#.#.......#...#\n#.#.###.#####.###\n#.#.#...#.....#.#\n#.#.#.#####.###.#\n#.#.#.........#.#\n#.#.#.#########.#\n#S#.............#\n#################"
g=ex2.grid();pos=ex2.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]];dontReturn=new Set(); lowest=0; found=[];while (queue.length){let here=queue.min(a=>a[2]);if(here[2]>lowest)console.log({lowest:(lowest=here[2]),queueSize:queue.length});queue.splice(queue.indexOf(here),1); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000],[here[0],(here[1]+2)%4,here[2]+2000]].filter(a=>get(a[0])!=="#"&&!dontReturn.has(a[0].Js())); dontReturn.add(here[0].Js());next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found.min(a=>a[2],true)
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]];dontReturn=new Set(); lowest=0; found=[];while (queue.length){let here=queue.min(a=>a[2]);if(here[2]>lowest)console.log({lowest:(lowest=here[2]),queueSize:queue.length});queue.splice(queue.indexOf(here),1); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000],[here[0],(here[1]+2)%4,here[2]+2000]].filter(a=>get(a[0])!=="#"&&!dontReturn.has(a[0].Js())); dontReturn.add(here[0].Js());next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found.min(a=>a[2],true)
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]];dontReturn=new Set(); lowest=0; found=[];while (queue.length){let here=queue.min(a=>a[2]);if(here[2]>lowest)console.log({lowest:(lowest=here[2]),queueSize:queue.length});queue.splice(queue.indexOf(here),1); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000],[here[0],(here[1]+2)%4,here[2]+2000]].filter(a=>get(a[0])!=="#"&&!dontReturn.has(a[0].Js())); dontReturn.add(here[0].Js());next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found
i
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]];dontReturn=new Map(); lowest=0; found=[];while (queue.length){let here=queue.min(a=>a[2]);if(here[2]>lowest)console.log({lowest:(lowest=here[2]),queueSize:queue.length});queue.splice(queue.indexOf(here),1); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000],[here[0],(here[1]+2)%4,here[2]+2000]].filter(a=>get(a[0])!=="#"&&!(dontReturn.get(a[0].Js())<=here[2])); dontReturn.set(here[0].Js(),here[2]);next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]];dontReturn=new Set(); lowest=0; found=[];while (queue.length){let here=queue.min(a=>a[2]);if(here[2]>lowest)console.log({lowest:(lowest=here[2]),queueSize:queue.length});queue.splice(queue.indexOf(here),1); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000],[here[0],(here[1]+2)%4,here[2]+2000]].filter(a=>get(a[0])!=="#"&&!dontReturn.has(a.slice(0,1).Js())); dontReturn.add(here.slice(0,1).Js());next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found.min(a=>a[2],true)
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]];dontReturn=new Set(); lowest=0; found=[];while (queue.length){let here=queue.min(a=>a[2]);if(here[2]>lowest)console.log({lowest:(lowest=here[2]),queueSize:queue.length});queue.splice(queue.indexOf(here),1); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000],[here[0],(here[1]+2)%4,here[2]+2000]].filter(a=>get(a[0])!=="#"&&!a[2]>dontReturn.get(a.slice(0,1).Js())); dontReturn.set(here.slice(0,1).Js(),here[2]);next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found.min(a=>a[2],true)
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]];dontReturn=new Map(); lowest=0; found=[];while (queue.length){let here=queue.min(a=>a[2]);if(here[2]>lowest)console.log({lowest:(lowest=here[2]),queueSize:queue.length});queue.splice(queue.indexOf(here),1); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000],[here[0],(here[1]+2)%4,here[2]+2000]].filter(a=>get(a[0])!=="#"&&!a[2]>dontReturn.get(a.slice(0,1).Js())); dontReturn.set(here.slice(0,1).Js(),here[2]);next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found.min(a=>a[2],true)
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]];dontReturn=new Map(); lowest=0; found=[];while (queue.length){let here=queue.min(a=>a[2]);if(here[2]>lowest)console.log({lowest:(lowest=here[2]),queueSize:queue.length});queue.splice(queue.indexOf(here),1); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000],[here[0],(here[1]+2)%4,here[2]+2000]].filter(a=>get(a[0])!=="#"&&!(a[2]>dontReturn.get(a.slice(0,1).Js()))); dontReturn.set(here.slice(0,1).Js(),here[2]);next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found.min(a=>a[2],true)
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]];dontReturn=new Map(); lowest=0; found=[];while (queue.length){let here=queue.min(a=>a[2]);if(here[2]>lowest)console.log({lowest:(lowest=here[2]),queueSize:queue.length});queue.splice(queue.indexOf(here),1); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000],[here[0],(here[1]+2)%4,here[2]+2000]].filter(a=>get(a[0])!=="#"&&!(a[2]<dontReturn.get(a.slice(0,1).Js()))); dontReturn.set(here.slice(0,1).Js(),here[2]);next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found.min(a=>a[2],true)
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]];dontReturn=new Map(); lowest=0; found=[];while (queue.length){let here=queue.min(a=>a[2]);if(here[2]>lowest)console.log({lowest:(lowest=here[2]),queueSize:queue.length});queue.splice(queue.indexOf(here),1); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000],[here[0],(here[1]+2)%4,here[2]+2000]].filter(a=>get(a[0])!=="#"&&!(a[2]>=dontReturn.get(a.slice(0,1).Js()))); dontReturn.set(here.slice(0,1).Js(),here[2]);next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found.min(a=>a[2],true)
g
g.last
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]]; lowest=0; found=[];while (queue.length){let here=queue.min(a=>a[2]);if(here[2]>lowest)console.log(lowest=here[2]);queue.splice(queue.indexOf(here),1); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000]].filter(a=>get(a[0])!=="#"); next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found.min(a=>a[2],true)
part 1
that took 31 minutes to run
that g
g=i.grid();pos=i.gridl().find(a=>a[1]==="S")[0].Jp();facing=0; queue=[[pos,0,0]];dontReturn=new Map(); lowest=0; found=[];while (queue.length){let here=queue.min(a=>a[2]);if(here[2]>lowest)console.log({lowest:(lowest=here[2]),queueSize:queue.length});queue.splice(queue.indexOf(here),1); if (here[2]-1001>found[0]?.[2])break;next=[[vadd(here[0],dirs4[here[1]]),here[1],here[2]+1],[here[0],(here[1]+5)%4,here[2]+1000],[here[0],(here[1]+3)%4,here[2]+1000],[here[0],(here[1]+2)%4,here[2]+2000]].filter(a=>get(a[0])!=="#"&&!(a[2]>=dontReturn.get(a.slice(0,1).Js()))); dontReturn.set(here.slice(0,1).Js(),here[2]);next.forEach(n=>{let existing=queue.find(a=>a[0][0]===n[0][0]&&a[0][1]===n[0][1]&&a[1]===n[1]);if(existing) existing[2]=Math.min(existing[2],n[2]); else queue.push(n);if(get(n[0])==="E")found.push(n);})}; found.min(a=>a[2],true)